// Name: Aravind Bhimarasetty
// USC loginid: bhimaras
// CS 455 PA4
// Fall 2015

import java.util.ArrayList;
import java.util.Scanner;
import java.util.HashMap;
import java.util.Map;
import java.util.Random;
import java.io.PrintWriter;
import java.lang.IllegalArgumentException;
/**
   The RandomTextGenerator class implements the random text generation using k-word prefixes, a HashMap, and other helper methods from the given text source, and  the following parameters: prefix length, debug mode, number of words to be generated.
 **/

public class RandomTextGenerator{

    /*
      The main data structures used are ArrayLists for storing the words from the input text file, and words generated and written to the output file, a HashMap that maps k-word prefix objects to an arraylist of successor words (multiple values for a key).
     */
    private ArrayList<String> list_of_words= new ArrayList<String>();
    private int num_words=0;
    private int prefix_len=0;
    private HashMap<Prefix, ArrayList<String>> hm;
    private Random rand;
    private boolean debugMode=false;
    private ArrayList<String> out_words= new ArrayList<String>();
    private int start_pos;
    private int num_words_out;
    public static final int MAX_CHARS=80;

    /**
       The contructor takes the scanner object, prefix length, debug mode and total no. of words to be generated.
       Error checking is performed to check if the number of words in the input file is too few relative to the prefix length
       After reading all the words from the input file, the contructor calls another method, called buildHM, to build the HashMap mapping the prefixes of the text to their successor word(s).
       It also creates a new Random object and selects a starting position of the first prefix randomly
    **/
    public RandomTextGenerator(Scanner sc, int pl, boolean debug, int n){

	prefix_len = pl;

	while(sc.hasNext()){

	    list_of_words.add(sc.next());
	}

	num_words= list_of_words.size();

	if (prefix_len >= num_words){
	    throw new IllegalArgumentException("ERROR: Prefix length >= number of words in sourceFile.");
	}

	buildHM();

	debugMode= debug;
	
	if (debug){//in debug mode, seed value is fixed (=1)
	    rand = new Random(1);
	}
	else{
	    rand= new Random();
	}

	start_pos= rand.nextInt(num_words- prefix_len);

	num_words_out= n;
	
    }
    /**The printListofWords method can be used to print the list of words read from the input text file.
     **/
    public void printListOfWords(){

	System.out.println(num_words);
	
	for(String s: list_of_words){
	    System.out.println(s);
	}
    }
    /**This method may be used for debugging purposes to print the HashMap generated by the contructor.
     **/
    public void printHM(){

	for(Map.Entry<Prefix, ArrayList<String>> entry : hm.entrySet()){

	    System.out.println(entry.getKey()+ ": "+ entry.getValue());
	}
    }
    /**The buildHM method builds a HashMap mapping the k-word prefix objects (keys) to their successor words (values). The prefix objects correspond to the k-word sequences starting from the first word and ending at the last word- prefix length.
       Each prefix object key can have multiple values if the same sequence of words appear in more than one place in the input text file.
     **/
    private void buildHM(){

	hm = new HashMap<Prefix, ArrayList<String>>();

	String[] prefix_words= new String[prefix_len];
	
	//Generate k-word sequences from the list of words read from the input text file
	for (int i=0;i<num_words-prefix_len;i++){
	    for(int j=0;j<prefix_len;j++){
		prefix_words[j]= list_of_words.get(i+j);
	    }

	    Prefix pre= new Prefix(prefix_words);
	    
	    if (hm.get(pre) !=null){//if key is already present in HM, then add the new successor word to the existing list of values
		hm.get(pre).add(list_of_words.get(i+prefix_len));
	    }
	    else{//if key is not present in the HM, then create a new entry
		ArrayList<String> al= new ArrayList<String>();
		al.add(list_of_words.get(i+prefix_len));
		hm.put(pre, al);
	    }
	}
    }
    /**
       The generateText method generates random words using word-level Markov generation method. Each of the generated words in stored in an arraylist.
       If at some point the prefix ends up at end of the text file, a new prefix is chosen at a random location and the process is continued.
    **/
    public void generateText(){

	String[] preWordsArr= new String[prefix_len];
	ArrayList<String> list_succ;

	//create a k-word prefix starting from the start_pos
	for (int i=0; i<prefix_len; i++){
	    preWordsArr[i]= list_of_words.get(start_pos+i);
	}
	Prefix curr_pre = new Prefix(preWordsArr);

	int sel_word_index;
	String sel_word="";
	int count=0;
	
	while(count < num_words_out){

	    list_succ = hm.get(curr_pre);//get the list of succesor words for the current prefix
	    
	    if(list_succ != null){//if prefix is not at the end of the text file

		//word selected randomly from the list of successor words
		sel_word_index= rand.nextInt(list_succ.size());
		sel_word = list_succ.get(sel_word_index);
		
		out_words.add(sel_word);

		if(debugMode){//print out the current prefix, succesor words, etc. if debug option was given
		    System.out.println("DEBUG: Current prefix: "+ curr_pre);
		    System.out.println("DEBUG: Current list of successors: "+ list_succ);
		    System.out.println("DEBUG: Word chosen: "+ sel_word);

		}
		
		count++;//maintain a count of the output words
		curr_pre= curr_pre.shiftin(sel_word);
	    }
	    else{//if prefix is at the end of text file, then chose new prefix starting at a random location
		start_pos= rand.nextInt(num_words- prefix_len);
		
		for (int i=0; i<prefix_len; i++){
		    preWordsArr[i]= list_of_words.get(start_pos+i);
		}
		curr_pre = new Prefix(preWordsArr);

	    }
	}
    }
    /**
       The writeWordsToFile method writes the random words generated & stored in the out_words arraylist to the output file in the specified format (flush left, ragged right, with a maximum line-length of 80 characers)
    **/
    public void writeWordsToFile(PrintWriter out){

	int num_chars= 0;
	
	for(String word: out_words){
	    num_chars+= word.length()+1;

	    if (num_chars <= MAX_CHARS){
		out.print(word+ " ");
	    }
	    else {//if num_chars will cross MAX_CHARS, then start a new line with that word
		num_chars= word.length()+1;
		
		out.print("\n");
		out.print(word+ " ");
	    }
	}
    }
	
   
	    
}

    
